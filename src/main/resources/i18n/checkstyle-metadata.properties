# This file is the merge of the .properties files in the eclipse-cs Eclipse CheckStyle plugin.
Annotation.group                      = Annotations

AnnotationUseStyle.closingParens      = Defines the policy for ending parenthesis.
AnnotationUseStyle.desc               = This check controls the style with the usage of annotations.
AnnotationUseStyle.elementStyle       = Defines the annotation element styles.
AnnotationUseStyle.name               = Annotation Use Style
AnnotationUseStyle.trailingArrayComma = Defines the policy for trailing comma in arrays.

MissingDeprecated.desc = Verifies that both the <code>java.lang.Deprecated</code> annotation is present and the <code>@deprecated<code> Javadoc tag is present when either is present.
MissingDeprecated.name = Missing Deprecated

MissingOverride.desc                  = Verifies that the <code>java.lang.Override</code> annotation is present when the <code>{@inheritDoc}</code> javadoc tag is present.
MissingOverride.javaFiveCompatibility = When this property is true this check will only check classes, interfaces, etc. that do not contain the extends or implements keyword or are not anonymous classes. This means it only checks methods overridden from java.lang.Object.Java 5 Compatibility mode severely limits this check. It is recommended to only use it on Java 5 source.
MissingOverride.name                  = Missing Override

PackageAnnotation.desc = \ This check makes sure that all package annotations are in the package-info.java file.<br/>\r\n<br/>\r\nAccording to the Java JLS 3rd ed.<br/>\r\n<br>\r\nThe JLS does not enforce the placement of package annotations. This placement may vary based on implementation. The JLS does highly recommend that all package annotations are placed in the package-info.java file. See <a target="_blank" href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java Language specification, sections 7.4.1.1</a>. 
PackageAnnotation.name = Package Annotation

SuppressWarnings.desc   = This check allows you to specify what warnings that SuppressWarnings is not allowed to suppress. You can also specify a list of TokenTypes that the configured warning(s) cannot be suppressed on.<br/>\r\n<br/>\r\nLimitations: This check does not consider conditionals inside the SuppressWarnings annotation.<br/>\r\nFor example: <code>@SupressWarnings((false) ? (true) ? "unchecked" : "foo" : "unused")</code>\r\n<br/>\r\nAccording to the above example, the "unused" warning is being suppressed not the "unchecked" or "foo" warnings. All of these warnings will be considered and matched against regardless of what the conditional evaluates to. 
SuppressWarnings.format = The warnings property is a regex pattern. Any warning being suppressed matching this pattern will be flagged.
SuppressWarnings.name   = Suppress Warnings
SuppressWarnings.tokens = tokens to check 
Blocks.group = Blocks

AvoidNestedBlocks.allowInSwitchCase = Allow nested blocks in case statements
AvoidNestedBlocks.desc              = Finds nested blocks, i.e. blocks that are used freely in the code.<br/>\r\nRationale: Nested blocks are often leftovers from the debugging process, they confuse the reader.
AvoidNestedBlocks.name              = Avoid Nested Blocks

EmptyBlock.desc   = Checks for empty blocks.
EmptyBlock.name   = Empty Block
EmptyBlock.option = policy on block contents
EmptyBlock.tokens = blocks to check

LeftCurly.desc          = Checks for the placement of left curly braces (<code>'{'</code>) for code blocks.<br/>\r\nThe policy to verify is specified using property <code>option</code>.<br/>\r\nPolicies <scode>eol</code> and <code> nlow</code> take into account property <code>maxLineLength</code>.
LeftCurly.maxLineLength = maximum number of characters in a line
LeftCurly.name          = Left Curly Brace Placement
LeftCurly.option        = policy on placement of a left curly brace ('{')
LeftCurly.tokens        = blocks to check

NeedBraces.desc   = Checks for braces around code blocks.
NeedBraces.name   = Need Braces
NeedBraces.tokens = blocks to check

RightCurly.desc             = Checks the placement of right curly braces (<code>'}'</code>) for <code> else</code>, <code>try</code>, and <code>catch</code> tokens.<br/>\r\nThe policy to verify is specified using property <code>option</code>.
RightCurly.name             = Right Curly Brace Placement
RightCurly.option           = policy on placement of a right curly brace ('}')  \u0009 
RightCurly.shouldStartLine  = should we check if '}'  starts line.
RightCurly.tokens           = blocks to check

ArrayTypeStyle.desc      = Checks the style of array type definitions. Some like Java-style: public static void main(String[] args) and some like C-style: public static void main(String args[]).
ArrayTypeStyle.javaStyle = Controls whether to enforce Java style (true) or C style (false).
ArrayTypeStyle.name      = Array Type Style

DescendantToken.desc           = Checks for restricted tokens beneath other tokens.<br/>\r\nWARNING: This is a very powerful and flexible check, but, at the same time, it is low level and very implementation dependent because its results depend on the grammar we use to build abstract syntax trees. Thus we recomend using other checks when they provide the desired funcionality. All in all, this check just works on the level of an abstract tree and knows nothing about language structures. 
DescendantToken.limitedTokens  = Tokens to check.
DescendantToken.maximumDepth   = the maximum depth for descendant counts
DescendantToken.maximumMessage = error message when maximum count exceeded
DescendantToken.maximumNumber  = a maximum count for descendants
DescendantToken.minimumDepth   = the mimimum depth for descendant counts
DescendantToken.minimumMessage = error message when minimum count not reached 
DescendantToken.minimumNumber  = a minimum count for descendants
DescendantToken.name           = Descendent Token Check
DescendantToken.sumTokenCounts = whether the number of tokens found should be calculated from the sum of the individual token counts 
DescendantToken.tokens         = Tokens to check.

FinalParameters.desc   = Check that method/constructor parameters are final. Interface methods are not checked - the final keyword does not make sense for interface method parameters as there is no code that could modify the parameter.<br/>\r\nRationale: Changing the value of parameters during the execution of the method's algorithm can be confusing and should be avoided. A great way to let the Java compiler prevent this coding style is to declare parameters final.
FinalParameters.name   = Final Parameters
FinalParameters.tokens = Tokens to check.

GenericIllegalRegexp.desc           = A generic check for code problems - the user can search for any pattern. This is similar to a recursive grep, only that it's integrated in checkstyle.<br/>\r\nRationale: This check can be used to prototype checks and to find common bad practice such as calling <code>ex.printStacktrace()</code>, <code>System.out.println()</code>, <code>System.exit()</code>, etc. 
GenericIllegalRegexp.format         = Pattern to check for.
GenericIllegalRegexp.ignoreCase     = Controls whether to ignore case when searching.
GenericIllegalRegexp.ignoreComments = Controls whether to ignore text in comments when searching.
GenericIllegalRegexp.message        = Message which is used to notify about violations, if empty then default(hard-coded) message is used.
GenericIllegalRegexp.name           = Generic Illegal Regexp

Indentation.basicOffset     = how many spaces to use for new indentation level
Indentation.braceAdjustment = how far brace should be indented when on next line
Indentation.caseIndent      = how much to indent a case label
Indentation.desc            = Checks correct indentation of Java Code.<br/>\r\nThe basic idea behind this is that while pretty printers are sometimes convienent for bulk reformats of legacy code, they often either aren't configurable enough or just can't anticipate how format should be done. Sometimes this is personal preference, other times it is practical experience. In any case, this check should just ensure that a minimal set of indentation rules are followed.       
Indentation.name            = Indentation

J2EE.group = J2EE

Miscellaneous.group = Miscellaneous

NewlineAtEndOfFile.desc           = Checks whether files end with a new line.<br/>\r\nRationale: Any source files and text files in general should end with a newline character, especially when using SCM systems such as CVS. CVS will even print a warning when it encounters a file that doesn't end with a newline. 
NewlineAtEndOfFile.fileExtensions = file type extension of the files to check.
NewlineAtEndOfFile.lineSeparator  = type of line separator 
NewlineAtEndOfFile.name           = New Line At End Of File

Regexp.desc           = A check that makes sure that a specified pattern exists, exists less than a set number of times, or does not exist in the file.<br/>\r\nThis check combines all the functionality provided by RegexpHeader, GenericIllegalRegexp and RequiredRegexp, except supplying the regular expression from a file.\r\n<br/>\r\nIt differs from them in that it works in multiline mode. It's regular expression can span multiple lines and it checks this against the whole file at once. The others work in singleline mode. Their single or multiple regular expressions can only span one line. They check each of these against each line in the file in turn.\r\n<br/>\r\nNote: Because of the different mode of operation there may be some changes in the regular expressions used to achieve a particular end.\r\n<br/>\r\nIn multiline mode...\r\n<ul>\r\n<li>^ means beginning of a line, as oposed to beginning of input.</li>\r\n<li>For beginning of input use \\A.</li>\r\n<li>$ means end of a line, as oposed to end of input.</li>\r\n<li>For end of input use \\Z.</li>\r\n<li>Each line in the file is terminated with a newline character.</li>\r\n</ul>\r\nNote: Not all regexp engines are created equal. Some provide extra functions that others do not and some elements of the syntax may vary. This check makes use of the java.util.regex package, please check its documentation for details of how to construct a regular expression to achive a particular goal.\r\n<br/>\r\nNote: When entering a regular expression as a parameter in the xml config file you must also take into account the xml rules. e.g. if you want to match a < symbol you need to enter &lt;. The regular expression should be entered on one line. 
Regexp.duplicateLimit = Controls whether to check for duplicates of a required pattern, any negative value means no checking for duplicates, any positive value is used as the maximum number of allowed duplicates, if the limit is exceeded errors will be logged. 
Regexp.errorLimit     = Controls the maximum number of errors before the check will abort. 
Regexp.format         = Regular expression pattern.
Regexp.ignoreComments = Controls whether to ignore matches found within comments. 
Regexp.illegalPattern = Controls whether the pattern is required or illegal. 
Regexp.message        = message which is used to notify about violations, if empty then default(hard-coded) message is used. 
Regexp.name           = Regexp

RequiredRegexp.desc   = A check that makes sure that a specified pattern exists in the code, e.g. a required legal text. It does not care about where in the file the pattern is
RequiredRegexp.format = required pattern
RequiredRegexp.name   = Required Regular Expression

TodoComment.desc   = A check for TODO: comments. Actually it is a generic regular expression matcher on Java comments. To check for other patterns in Java comments, set property format.
TodoComment.format = Regular expression definging pattern to look for.
TodoComment.name   = Todo Comment

TrailingComment.desc         = The check to ensure that requires that comments be the only thing on a line. For the case of // comments that means that the only thing that should precede it is whitespace. It doesn't check comments if they do not end line, i.e. it accept the following: Thread.sleep( 10 <some comment here> ); Format property is intended to deal with the "} // while" example.<br/>\r\nRationale: Steve McConnel in "Code Complete" suggests that endline comments are a bad practice. An end line comment would be one that is on the same line as actual code. For example:\r\n<pre>\r\na = b + c;      // Some insightful comment\r\nd = e / f;        // Another comment for this line\r\n</pre>\r\nQuoting "Code Complete" for the justfication:<br/>\r\n<ul>\r\n<li>"The comments have to be aligned so that they do not interfere with the visual structure of the code. If you don't align them neatly, they'll make your listing look like it's been through a washing machine."</li>\r\n<li>"Endline comments tend to be hard to format...It takes time to align them. Such time is not spent learning more about the code; it's dedicated solely to the tedious task of pressing the spacebar or tab key."</li>\r\n<li>"Endline comments are also hard to maintain. If the code on any line containing an endline comment grows, it bumps the comment farther out, and all the other endline comments will have to bumped out to match. Styles that are hard to maintain aren't maintained...."</li>\r\n<li>"Endline comments also tend to be cryptic. The right side of the line doesn't offer much room and the desire to keep the comment on one line means the comment must be short. Work then goes into making the line as short as possible instead of as clear as possible. The comment usually ends up as cryptic as possible...."</li>\r\n<li>"A systemic problem with endline comments is that it's hard to write a meaningful comment for one line of code. Most endline comments just repeat the line of code, which hurts more than it helps."</li>\r\n</ul>\r\nHis comments on being hard to maintain when the size of the line changes are even more important in the age of automated refactorings. 
TrailingComment.format       = pattern for string allowed before comment.
TrailingComment.legalComment = pattern for text of trailing comment which is allowed. (this pattern will not be applied to multiline comments and text of comment will be trimmed before matching) 
TrailingComment.name         = Trailing Comment

Translation.desc           = A FileSetCheck that ensures the correct translation of code by checking property files for consistency regarding their keys. Two property files describing one and the same context are consistent if they contain the same keys.<br/>\r\nConsider the following properties file in the same directory:\r\n<pre>\r\n#messages.properties\r\nhello=Hello\r\ncancel=Cancel\r\n\r\n#messages_de.properties\r\nhell=Hallo\r\nok=OK\r\n</pre>\r\nThe Translation check will find the typo in the german hello key, the missing ok key in the default resource file and the missing cancel key in the german resource file:\r\n<pre>\r\nmessages_de.properties: Key 'hello' missing.\r\nmessages_de.properties: Key 'cancel' missing.\r\nmessages.properties: Key 'hell' missing.\r\nmessages.properties: Key 'ok' missing.\r\n</pre>\r\n\u0009
Translation.fileExtensions = file type extension to identify translation files. Setting this property is typically only required if your translation files are preprocessed and the original files do not have the extension .properties
Translation.name           = Translation

UncommentedMain.desc            = Checks for uncommented main() methods (debugging leftovers).<br/>\r\nRationale: A main() method is often used for debug puposes. When debugging is finished, developers often forget to remove the method, which changes the API and increases the size of the resulting class/jar file. With the exception of the real program entry points, all main() methods should be removed/commented out of the sources. 
UncommentedMain.excludedClasses = pattern for qualified names of classes which ar allowed to have main method.
UncommentedMain.name            = Uncommented Main

UpperEll.desc = Checks that long constants are defined with an upper ell. That is ' L' and not 'l'. This is in accordance to the Java Language Specification, Section 3.10.1.<br/>\r\nRationale: The lower case letter l looks a lot like the digit 1.
UpperEll.name = Upper Ell

OuterTypeFilename.name = Outer Type File Name
OuterTypeFilename.desc = Checks that the outer type name and the file name match. For example, the class Foo must be in a file named <code>Foo.java</code>. 
ArrayTrailingComma.desc = Checks that array initialization contains a trailing comma.\r\n<pre>\r\nint[] a = new int[]\r\n{\r\n    1,\r\n    2,\r\n    3,\r\n};\r\n</pre>\r\nThe check allows to not add a comma if both left and right curlys are on the same line.\r\n<pre>\r\nreturn new int[] { 0 };\r\n</pre>\r\nRationale: Putting this comma in makes it easier to change the order of the elements or add new elements on the end.
ArrayTrailingComma.name = Trailing Array Comma

AvoidInlineConditionals.desc = Detects inline conditionals. An example inline conditional is this:\r\n<pre>\r\nString a = getParameter("a");\r\nString b = (a==null || a.length<1) ? null : a.substring(1);\r\n</pre>\r\nRationale: Some developers find inline conditionals hard to read, so their company's coding standards forbids them.
AvoidInlineConditionals.name = Avoid Inline Conditionals

Coding.group = Coding Problems

CovariantEquals.desc = Checks that classes that define a covariant equals() method also override method equals(java.lang.Object). Inspired by findbugs.<br/>\r\nRationale: Mistakenly defining a covariant equals() method without overriding method equals(java.lang.Object) can produce unexpected runtime behaviour. 
CovariantEquals.name = Covariant Equals

DeclarationOrder.desc = According to <a href="http://java.sun.com/docs/codeconv/html/CodeConventions.doc2.html#1852" target="_blank">Code Conventions for the Java Programming Language</a> , the parts of a class or interface declaration should appear in the following order:\r\n<ol>\r\n<li>Class (static) variables. First the public class variables, then the protected, then package level (no access modifier), and then the private.</li>\r\n<li>Instance variables. First the public class variables, then the protected, then package level (no access modifier), and then the private.</li>\r\n<li>Constructors </li>\r\n<li>Methods</li>\r\n</ol>\r\n
DeclarationOrder.name = Declaration Order Check
DeclarationOrder.ignoreConstructors = whether to ignore constructors
DeclarationOrder.ignoreMethods      = whether to ignore methods
DeclarationOrder.ignoreModifiers    = whether to ignore modifiers

DefaultComesLast.desc = Check that the <code>default</code> is after all the cases in a <code>switch</code> statement.<br/>\r\nRationale: Java allows <code>default</code> anywhere within the <code>switch</code> statement. But it is more readable if it comes after the last case. 
DefaultComesLast.name = Default Comes Last

EmptyStatement.desc = Detects empty statements (standalone ;).
EmptyStatement.name = Empty Statement

EqualsAvoidNull.desc = Checks that any combination of String literals with optional assignment is on the left side of an equals() comparison.<br/>The check also processes <code>String.equalsIgnoreCase()</code> invocations (which can be suppressed).\r\n<br/><br/>\r\nRationale: Calling the equals() method on String literals will avoid a potential NullPointerException. Also, it is pretty common to see null check right before equals comparisons which is not necessary in the below example.<br/>\r\n<br/>\r\nFor example:\r\n<pre>\r\nString nullString = null;\r\nnullString.equals("My_Sweet_String");\u0009\r\n</pre>\r\nshould be refactored to:\u0009\r\n<pre>\u0009\r\nString nullString = null;\r\n"My_Sweet_String".equals(nullString);\r\n</pre>\r\nLimitations: If the equals method is overridden or a covariant equals method is defined and the implementation is incorrect (where s.equals(t) does not return the same result as t.equals(s)) then rearranging the called on object and parameter may have unexpected results.<br/>\r\n<br/>\r\nJava's Autoboxing feature has an affect on how this check is implemented. Pre Java 5 all IDENT + IDENT object concatenations would not cause a NullPointerException even if null. Those situations could have been included in this check. They would simply act as if they surrounded by String.valueof() which would concatenate the String null.<br/>\r\n<br/>\r\nThe following example will cause a NullPointerException as a result of what autoboxing does.\r\n<pre>\r\nInteger i = null, j = null;\r\nString number = "5"\r\nnumber.equals(i + j);\r\n</pre>\r\nSince, it is difficult to determine what kind of Object is being concatenated all ident concatenation is considered unsafe.
EqualsAvoidNull.name = Equals Avoid Null
EqualsAvoidNull.ignoreEqualsIgnoreCase = Whether to ignore String.equalsIgnoreCase() invocations

EqualsHashCode.desc = Checks that classes that override <code>equals()</code>  also override <code>hashCode()</code>.<br/>\r\nRationale: The contract of <code>equals()</code> and <code>hashCode()</code> requires that equal objects have the same hashCode. Hence, whenever you override <code>equals()</code> you must override <code>hashCode()</code> to ensure that your class can be used in collections that are hash based. 
EqualsHashCode.name = Equals and HashCode

ExplicitInitialization.desc = Checks if any class or object member explicitly initialized to default for its type value (<code>null</code> for object references, zero for numeric types and <code>char</code> and <code>false</code> for <code>boolean</code>.<br/>\r\nRationale: each instance variable gets initialized twice, to the same value. Java initializes each instance variable to its default value (0 or null) before performing any initialization specified in the code. So in this case, x gets initialized to 0 twice, and bar gets initialized to null twice. So there is a minor inefficiency. This style of coding is a hold-over from C/C++ style coding, and it shows that the developer isn't really confident that Java really initializes instance variables to default values. 
ExplicitInitialization.name = Explicit Initialization

FallThrough.checkLastCaseGroup = Whether we need to check last case group or not.
FallThrough.desc               = Checks for fall through in switch  statements Finds locations where a <code>case</code> contains Java code - but lacks a <code>break, return, throw</code> or <code>continue</code> statement.<br/>\r\nThe check honores special comments to supress the warning. By default the text "fallthru", "fall through", "fallthrough", "falls through" and "fallsthrough" are recognized (case sensitive). The comment containing this words must be a one-liner and must be on the last none-empty line before the <code>case</code> triggering the warning or on the same line before the <code>case</code> (urgly, but possible).\r\n<pre>\r\nswitch (i){\r\ncase 0:\r\n    i++; // fall through\r\n\r\ncase 1:\r\n    i++;\r\n    // falls through\r\ncase 2: {\r\n    i++;\r\n}\r\n// fallthrough\r\ncase 3:\r\n    i++;\r\n/* fallthru */case 4:\r\n    i++\r\n    break;\r\n}\r\n</pre>\u0009\r\nNote: the check works in assumption that there is no unreachable code in the <code>case</code>.
FallThrough.name               = Fall Through
FallThrough.reliefPattern      = Regular expression to match the relief comment that supresses the warning about a fall through. 

FinalLocalVariable.desc   = Checks that local variables that never have their values changed are declared final. The check can be configured to also check that unchanged parameters are declared final.<br/>\r\nWhen configured to check parameters, the check ignores parameters of interface methods and abstract methods.
FinalLocalVariable.name   = Final Local Variable
FinalLocalVariable.tokens = Tokens to check.

HiddenField.desc                       = Checks that a local variable or a parameter does not shadow a field that is defined in the same class.
HiddenField.ignoreAbstractMethods      = Controls whether to ignore parameters of abstract methods.
HiddenField.ignoreConstructorParameter = Controls whether to ignore constructor parameters.
HiddenField.ignoreFormat               = pattern for names to ignore
HiddenField.ignoreSetter               = Controls whether to ignore the parameter of a property setter method, where the property setter method for field "xyz" has name "setXyz", one parameter named "xyz", and return type void.
HiddenField.name                       = Hidden Field
HiddenField.tokens                     = Tokens to check.

IllegalCatch.desc              = Catching java.lang.Exception, java.lang.Error or java.lang.RuntimeException is almost never acceptable.<br/>\r\nRationale: Junior developers often simply catch Exception in an attempt to handle multiple exception classes. This unfortunately leads to code that inadvertantly catchs NPE, OutOfMemoryErrors, etc.
IllegalCatch.illegalClassNames = exception class names to reject
IllegalCatch.name              = Illegal Catch

IllegalInstantiation.classes = Comma seperated list of classes that should not be instantiated.
IllegalInstantiation.desc    = Checks for illegal instantiations where a factory method is preferred.<br/>\r\nRationale: Depending on the project, for some classes it might be preferable to create instances through factory methods rather than calling the constructor.\r\n<p>\r\nA simple example is the java.lang.Boolean class. In order to save memory and CPU cycles, it is preferable to use the predefined constants <code>TRUE</code> and <code>FALSE</code>. Constructor invocations should be replaced by calls to <code>Boolean.valueOf()</code>.\r\n</p>\r\nSome extremely performance sensitive projects may require the use of factory methods for other classes as well, to enforce the usage of number caches or object pools. 
IllegalInstantiation.name    = Illegal Instantiation

IllegalThrows.desc              = This check can be used to ensure that types are not declared to be thrown. Declaring to throw java.lang.Error or java.lang.RuntimeException is almost never acceptable.
IllegalThrows.illegalClassNames = throw class names to reject
IllegalThrows.name              = Illegal Throws
IllegalThrows.ignoredMethodNames= names of methods to ignore

IllegalToken.desc           = Checks for illegal tokens.<br/>\r\nRational: Certain language features often lead to hard to maintain code or are non-obvious to novice developers. Other features may be discouraged in certain frameworks, such as not having native methods in EJB components. 
IllegalToken.name           = Illegal Tokens
IllegalToken.tokens         = Tokens to check.

IllegalTokenText.desc       = Checks for illegal token text.
IllegalTokenText.format     = illegal pattern
IllegalTokenText.ignoreCase = Controls whether to ignore case when matching.
IllegalTokenText.message    = Message which is used to notify about violations; if empty then the default message is used.
IllegalTokenText.name       = Illegal Tokens Text
IllegalTokenText.tokens     = Tokens to check.

IllegalType.desc                    = Checks that particular class are never used as types in variable declarations, return values or parameters. Includes a pattern check that by default disallows abstract classes.<br/>\r\nRationale: Helps reduce coupling on concrete classes. In addition abstract classes should be thought of a convenience base class implementations of interfaces and as such are not types themselves. 
IllegalType.format                  = pattern for illegal class name 
IllegalType.ignoredMethodNames      = methods that should not be checked.
IllegalType.illegalClassNames       = classes that should not be used as types in variable declarations, return values or parameters.
IllegalType.legalAbstractClassNames = abstract classes that may be used as types. 
IllegalType.name                    = Illegal Type
IllegalType.tokens                  = Tokens to check.

InnerAssignment.desc   = Checks for assignments in subexpressions, such as in <code>String s = Integer.toString(i = 2);</code>.<br/>\r\nRationale: With the exception of for iterators, all assignments should occur in their own toplevel statement to increase readability. With inner assignments like the above it is difficult to see all places where a variable is set. 
InnerAssignment.name   = Inner Assignment
InnerAssignment.tokens = Tokens to check.

JUnitTestCase.desc = Ensures that the setUp(), tearDown() methods are named correctly, have no arguments, return void and are either public or protected.<br/>\r\nAlso ensures that suite() is named correctly, have no arguments, return junit.framewotk.Test, public and static.<br/>\r\nRationale: often times developers will misname one or more of these methods and not realise that the method is not being called. 
JUnitTestCase.name = Junit Test Case

MagicNumber.desc          = Checks that there are no "magic numbers", where a magic number is a numeric literal that is not defined as a constant. By default, -1, 0, 1, and 2 are not considered to be magic numbers.
MagicNumber.ignoreNumbers = Comma separated list of non-Magic numbers.
MagicNumber.name          = Magic Number
MagicNumber.tokens        = Tokens to check.
MagicNumber.ignoreHashCodeMethod = Ignore magic numbers in hashCode methods.
MagicNumber.ignoreAnnotation = Ignore magic numbers in annotation declarations.

MissingCtor.desc = Checks that classes (except abtract one) define a ctor and don't rely on the default one.
MissingCtor.name = Missing Constructor

MissingSwitchDefault.desc = Checks that switch statement has "default" clause.<br/>\r\nRationale: It's usually a good idea to introduce a default case in every switch statement. Even if the developer is sure that all currently possible cases are covered, this should be expressed in the default branch, e.g. by using an assertion. This way the code is protected aginst later changes, e.g. introduction of new types in an enumeration type. 
MissingSwitchDefault.name = Missing Switch Default

ModifiedControlVariable.desc = Check for ensuring that for loop control variables are not modified inside the for block. An example is:\r\n<pre>\r\nfor (int i = 0; i < 1; i++) {\r\n    i++;\r\n}\r\n</pre>\r\nRationale: If the control variable is modified inside the loop body, the program flow becomes more difficult to follow. An option is to replace the for loop with a while loop. 
ModifiedControlVariable.name = Modified Control Variable

MultipleStringLiterals.allowedDuplicates       = The maximum number of occurences to allow without generating a warning
MultipleStringLiterals.desc                    = Checks for multiple occurrences of the same string literal within a single file.<br/>\r\nRationale: Code duplication makes maintenance more difficult, so it can be better to replace the multiple occurrences with a constant. 
MultipleStringLiterals.ignoreOccurrenceContext = Token type names where duplicate strings are ignored even if they don't match ignoredStringsRegexp. This allows you to exclude syntactical contexts like Annotations or static initializers from the check.
MultipleStringLiterals.ignoreStringsRegexp     = Regexp pattern for ignored strings (with quotation marks)
MultipleStringLiterals.name                    = Multiple String Literals

MultipleVariableDeclarations.desc = Checks that each variable declaration is in its own statement and on its own line.<br/>\r\nRationale: <a href="http://java.sun.com/docs/codeconv/html/CodeConventions.doc5.html#2991" target="_blank"> the SUN Code conventions chapter 6.1</a> recommends that declarations should be one per line/statement.
MultipleVariableDeclarations.name = Multiple Variable Declaration

NestedForDepth.desc = Restricts nested <code>for</code> blocks to a specified depth (default = 1).
NestedForDepth.max  = allowed nesting depth
NestedForDepth.name = Nested For Depth

NestedIfDepth.desc = Restricts nested if-else blocks to a specified depth (default = 1).
NestedIfDepth.max  = allowed nesting depth
NestedIfDepth.name = Nested If Depth

NestedTryDepth.desc = Restricts nested try blocks to a specified depth (default = 1).
NestedTryDepth.max  = allowed nesting depth
NestedTryDepth.name = Nested Try Depth

NoClone.desc = Checks that the clone method is not overridden from the Object class.<br/>\r\n<br/>\r\nRationale: The clone method relies on strange/hard to follow rules that do not work it all situations. Consequently, it is difficult to override correctly. Below are some of the rules/reasons why the clone method should be avoided.<br/>\r\nClasses supporting the clone method should implement the Cloneable interface but the Cloneable interface does not include the clone method. As a result, it doesn't enforce the method override.<br/>\r\nThe Cloneable interface forces the Object's clone method to work correctly. Without implementing it, the Object's clone method will throw a CloneNotSupportedException.<br/>\r\nNon-final classes must return the object returned from a call to super.clone(). \r\nFinal classes can use a constructor to create a clone which is different from non-final classes.<br/>\r\n<ul>\r\n<li>If a super class implements the clone method incorrectly all subclasses calling super.clone() are doomed to failure.</li>\r\n<li>If a class has references to mutable objects then those object references must be replaced with copies in the clone method after calling super.clone().</li>\r\n<li>The clone method does not work correctly with final mutable object references because final references cannot be reassigned.</li>\r\n<li>If a super class overrides the clone method then all subclasses must provide a correct clone implementation.</li>\r\n</ul>\r\nTwo alternatives to the clone method, in some cases, is a copy constructor or a static factory method to return copies of an object. Both of these approaches are simpler and do not conflict with final fields. The do not force the calling client to handle a CloneNotSuportException. They also are typed therefore no casting is necessary. Finally, they are more flexible since they can take interface types rather than concrete classes.<br/>\r\n<br/>\r\nSometimes a copy constructor or static factory is not an acceptable alternative to the clone method. The example below highlights the limitation of a copy constructor (or static factory). Assume Square is a subclass for Shape. \r\n<pre>\r\n       Shape s1 = new Square();\r\n       System.out.println(s1 instanceof Square); //true\r\n</pre>\r\n...assume at this point the code knows nothing of s1 being a Square that's the beauty of polymorphism but the code wants to copy the Square which is declared as a Shape, its super type... \r\n<pre>\r\n       Shape s2 = new Shape(s1); //using the copy constructor\r\n       System.out.println(s2 instanceof Square); //false\r\n</pre>\r\nThe working solution (without knowing about all subclasses and doing many casts) is to do the following (assuming correct clone implementation). \r\n<pre>\r\n       Shape s2 = s1.clone();\r\n       System.out.println(s2 instanceof Square); //true\r\n</pre>\r\nJust keep in mind if this type of polymorphic cloning is required then a properly implemented clone method may be the best choice.<br/>\r\n<br/>\r\nMuch of this information was taken from Effective Java: Programming Language Guide First Edition by Joshua Bloch pages 45-52. Give Bloch credit for writing an excellent book.<br/>\r\n<br/>\r\nThis check is almost exactly the same as the {@link NoFinalizerCheck}
NoClone.name = No Clone

NoFinalizer.desc = Verifies there are no <code>finalize()</code> methods defined in a class. 
NoFinalizer.name = No Finalizer

PackageDeclaration.desc = Ensure a class is has a package declaration, and (optionally) whether the package name matches the directory name for the source file.<br/>\r\nRationale: Classes that live in the null package cannot be imported. Many novice developers are not aware of this. 
PackageDeclaration.name = Package Declaration
PackageDeclaration.ignoreDirectoryName = Whether to ignore checking that the package declaration matches the source directory name.

ParameterAssignment.desc = Disallow assignment of parameters.<br/>\r\nRationale: Parameter assignment is often considered poor programming practice. Forcing developers to declare parameters as final is often onerous. Having a check ensure that parameters are never assigned would give the best of both worlds.
ParameterAssignment.name = Parameter Assignment

RedundantThrows.allowSubclasses    = Whether subclass of another declared exception is allowed in throws clause.
RedundantThrows.allowUnchecked     = Whether unchecked exceptions in throws are allowed or not.
RedundantThrows.desc               = Checks for redundant exceptions declared in throws clause such as duplicates, unchecked exceptions or subclasses of another declared exception.
RedundantThrows.logLoadErrors      = This check may needs to load exception classes mentioned in the @throws tag to check whether they are RuntimeExceptions. If loading the class fails, this property allows to control checkstyle's error handling. If set to false (the default) a classpath configuration problem is assumed and the TreeWalker stops operating on the class completely. If set to true, checkstyle assumes a typo or refactoring problem in the javadoc and logs the problem in the normal checkstyle report (potentially masking a configuration error).
RedundantThrows.name               = Redundant Throws
RedundantThrows.suppressLoadErrors = Controls whether to show class loading errors in the checkstyle report.

RequireThis.checkFields  = whether we should check fields usage or not
RequireThis.checkMethods = whether we should check methods usage or not
RequireThis.desc         = Checks that code doesn't rely on the "this." default, i.e. references to instance variables and methods of the present object are explicitly of the form "this.varName" or "this.methodName(args)".
RequireThis.name         = Require This

ReturnCount.desc   = Restricts the number of return statements. Default = 2. Ignores specified methods (<code>equals()</code> by default).<br/>\r\nRationale: Too many return points can be indication that code is attempting to do too much or may be difficult to understand. 
ReturnCount.format = method names to ignore
ReturnCount.max    = maximum allowed number of return statements
ReturnCount.name   = Return Count

SimplifyBooleanExpression.desc = Checks for overly complicated boolean expressions. Currently finds code like  <code>if (b == true), b || true, !false</code>, etc.<br/>\r\nRationale: Complex boolean logic makes code hard to understand and maintain. 
SimplifyBooleanExpression.name = Simplify Boolean Expression

SimplifyBooleanReturn.desc = Checks for overly complicated boolean return statements. For example the following code\r\n<pre>\r\nif (valid())\r\n    return false;\r\nelse\r\n    return true;\r\n</pre>\r\ncould be written as\r\n<pre>\r\nreturn !valid();\r\n</pre>\r\nThe Idea for this Check has been shamelessly stolen from the equivalent <a href="http://pmd.sourceforge.net/" target="_blank">PMD</a> rule. 
SimplifyBooleanReturn.name = Simplify Boolean Return

StringLiteralEquality.desc = Checks that string literals are not used with == or !=.<br/>\r\nRationale: Novice Java programmers often use code like:\r\n<pre>\r\nif (x == "something")\r\n</pre>\r\nwhen they mean\r\n<pre>\r\nif ("something".equals(x))\r\n</pre>\r\n\u0009\r\n\u0009\u0009
StringLiteralEquality.name = String Literal Equality

SuperClone.desc = Checks that an overriding <code>clone()</code> method invokes <code>super.clone()</code>.<br/>\r\nReference: <a href="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#clone%28%29" target="_blank">Object.clone()</a>.
SuperClone.name = SuperClone

SuperFinalize.desc = Checks that an overriding <code>finalize()</code> method invokes <code>super.finalize()</code>.<br/>\r\nReference: <a href="http://java.sun.com/docs/books/tutorial/java/data/garbagecollection.html" target="_blank">Cleaning Up Unused Objects</a>.
SuperFinalize.name = SuperFinalize

UnnecessaryParentheses.desc = Checks for the use of unnecessary parentheses.
UnnecessaryParentheses.name = Unnecessary Parentheses

OneStatementPerLine.name = One Statement Per Line
OneStatementPerLine.desc = Checks there is only one statement per line. The following line will be flagged as an error:<br/><code>x = 1; y = 2; // Two statments on a single line.</code>Design.group = Class Design

DesignForExtension.desc = Checks that classes are designed for extension. More specifically, it enforces a programming style where superclasses provide empty "hooks" that can be implemented by subclasses.<br/>\r\nThe exact rule is that nonprivate, nonstatic methods of classes that can be subclassed must either be\r\n<ul>\r\n<li>abstract or</li>\r\n<li>final or</li>\r\n<li>have an empty implementation</li>\r\n</ul>\r\nRationale: This API design style protects superclasses against beeing broken by subclasses. The downside is that subclasses are limited in their flexibility, in particular they cannot prevent execution of code in the superclass, but that also means that subclasses cannot corrupt the state of the superclass by forgetting to call the super method. 
DesignForExtension.name = Design For Extension

FinalClass.desc = Checks that a class which has only private constructors is declared as final.
FinalClass.name = Final Class

InnerTypeLast.desc = Check nested/internal types to be declared at the bottom of the class (after all methods/fields declaration).
InnerTypeLast.name = Inner Type Last

HideUtilityClassConstructor.desc = Make sure that utility classes (classes that contain only static methods or fields in their API) do not have a public constructor.<br/>\r\nRationale: Instantiating utility classes does not make sense. Hence the constructors should either be private or (if you want to allow subclassing) protected. A common mistake is forgetting to hide the default constructor.<br/><br/>\r\nIf you make the constructor protected you may want to consider the following constructor implementation technique to disallow instantiating subclasses:\r\n<pre>\r\npublic class StringUtils // not final to allow subclassing\r\n{\r\n    protected StringUtils() {\r\n        throw new UnsupportedOperationException(); // prevents calls from subclass\r\n    }\r\n\r\n    public static int count(char c, String s) {\r\n        // ...\r\n    }\r\n}\r\n</pre>\r\n\r\n\u0009
HideUtilityClassConstructor.name = Hide Utility Class Constructor

InterfaceIsType.allowMarkerInterfaces = Controls whether marker interfaces like Serializable are allowed.
InterfaceIsType.desc                  = Implements Bloch, Effective Java, Item 17 - Use Interfaces only to define types.<br/>\r\nAccording to Bloch, an interface should describe a <em>type</em>. It is therefore inappropriate to define an interface that does not contain any methods but only constants. The Standard class <a href="http://java.sun.com/j2se/1.4.1/docs/api/javax/swing/SwingConstants.html" target="_blank">javax.swing.SwingConstants</a> is an example of a class that would be flagged by this check.<br/><br/>\r\nThe check can be configured to also disallow marker interfaces like <code>java.io.Serializable</code>, that do not contain methods or constants at all.
InterfaceIsType.name                  = Interface Is Type

MutableException.desc   = Ensures that exceptions (defined as any class name conforming to some regular expression) are immutable. That is, have only final fields.<br/>\r\nThe current algorithm is very simple it checks that all members of exception are final. User can still mutates an exception's instance (e.g. Throwable has setStackTrace(StackTraceElement[] stackTrace) method which changes stack trace). But, at least, all information provided by this exception type is unchangable.<br/>\r\nRationale: Exception instances should represent an error condition. Having non final fields not only allows the state to be modified by accident and therefore mask the original condition but also allows developers to accidentally forget to initialise state thereby leading to code catching the exception to draw incorrect conclusions based on the state. 
MutableException.format = pattern for name of exception class.
MutableException.name   = Mutable Exception

ThrowsCount.desc = Restricts throws statements to a specified count (default = 1).<br/>\r\nRationale: Exceptions form part of a methods interface. Declaring a method to throw too many differently rooted exceptions makes exception handling onerous and leads to poor programming practices such as catch (Exception). This check forces developers to put exceptions into a heirachy such that in the simplest case, only one type of exception need be checked for by a caller but allows any sub-classes to be caught specifically if necessary. 
ThrowsCount.max  = maximum allowed number of throws statments
ThrowsCount.name = Throws Count

VisibilityModifier.desc                = Checks visibility of class members. Only static final members may be public; other class members must be private unless property protectedAllowed or packageAllowed is set.<br/>\r\nPublic members are not flagged if the name matches the public member regular expression (contains "<code>^serialVersionUID$</code>" by default). Note: Checkstyle 2 used to include "<code>^f[A-Z][a-zA-Z0-9]*$</code>" in the default pattern to allow CMP for EJB 1.1 with the default settings. With EJB 2.0 it is not longer necessary to have public access for persistent fields, hence the default has been changed.<br/>\r\nRationale: Enforce encapsulation. 
VisibilityModifier.name                = Visibility Modifier
VisibilityModifier.packageAllowed      = Whether package visible members are allowed or not.
VisibilityModifier.protectedAllowed    = Whether protected members are allowed or not.
VisibilityModifier.publicMemberPattern = Pattern for public members that should be ignored.
Duplicates.group = Duplicates

StrictDuplicateCode.charset = name of the file charset
StrictDuplicateCode.desc    = Performs a line-by-line comparison of all code lines and reports duplicate code if a sequence of lines differs only in indentation. All import statements in Java code are ignored, any other line - including javadoc, whitespace lines between methods, etc. - is considered (which is why the check is called strict).
StrictDuplicateCode.min     = how many lines must be equal to be considered a duplicate
StrictDuplicateCode.name    = Strict Duplicate Code
Headers.group = Headers

Header.desc        = Checks that a source file begins with a specified header. Property  headerFile specifies a file that contains the required header. Alternatively, the header specification can be set directly in the <code>header</code> property without the need for an external file.<br/><br/>\r\nProperty <code>ignoreLines</code> specifies the line numbers to ignore when matching lines in a header file. This property is very useful for supporting headers that contain copyright dates. For example, consider the following header:\r\n<pre>\r\nline 1: ////////////////////////////////////////////////////////////////////\r\nline 2: // checkstyle:\r\nline 3: // Checks Java source code for adherence to a set of rules.\r\nline 4: // Copyright (C) 2002  Oliver Burn\r\nline 5: ////////////////////////////////////////////////////////////////////\r\n</pre>\r\nSince the year information will change over time, you can tell Checkstyle to ignore line 4 by setting property <code>ignoreLines</code> to 4. 
Header.header      = the required header specified inline. Individual header lines must be separated by the string "\\\\n" (even on platforms with a different line separator).
Header.headerFile  = name of the file containing the required header.
Header.charset     = character encoding to use when reading the headerFile (defaults to the charset property of the parent Checker module)
Header.ignoreLines = line numbers to ignore (comma separated)
Header.name        = Header
Header.fileExtensions = File type extension of files to process

RegexpHeader.desc       = Checks the header of a java source file against a header that contains a regular expression for each line of the source header.<br/>\r\nRationale: In some projects checking against a fixed header is not sufficient, e.g. the header might require a copyright line where the year information is not static.<br/>\r\nFor example, consider the following header:\r\n<pre>\r\nline  1: ^/{71}$\r\nline  2: ^// checkstyle:$\r\nline  3: ^// Checks Java source code for adherence to a set of rules\\.$\r\nline  4: ^// Copyright \\(C\\) \\d\\d\\d\\d  Oliver Burn$\r\nline  5: ^// Last modification by \\$Author.*\\$$\r\nline  6: ^/{71}$\r\nline  7:\r\nline  8: ^package\r\nline  9:\r\nline 10: ^import\r\nline 11:\r\nline 12: ^/\\*\\*\r\nline 13: ^ \\*([^/]|$)\r\nline 14: ^ \\*/\r\n</pre>\r\nLines 1 and 6 demonstrate a more compact notation for 71 '/' characters. Line 4 enforces that the copyright notice includes a four digit year. Line 5 is an example how to enforce revision control keywords in a file header. Lines 12-14 is a template for javadoc (line 13 is so complicated to remove conflict with and of javadoc comment). 
RegexpHeader.header     = the required header specified inline. Individual header lines must be separated by the string "\\\\n" (even on platforms with a different line separator), and regular expressions must not span multiple lines.
RegexpHeader.headerFile = name of the file containing the required header.
RegexpHeader.charset    = character encoding to use when reading the headerFile (defaults to the charset property of the parent Checker module)
RegexpHeader.multiLines = line numbers to repeat (zero or more times)
RegexpHeader.name       = Regular Expression Header
RegexpHeader.fileExtensions = File type extension of files to process
AvoidStarImport.desc     = Checks that there are no import statements that use the * notation.<br/>\r\nRationale: Importing all classes from a package leads to tight coupling between packages and might lead to problems when a new version of a library introduces name clashes.
AvoidStarImport.excludes = packages where star imports are allowed. Note that this property is not recursive, subpackages of excluded packages are not automatically excluded.
AvoidStarImport.name     = Avoid Star (Demand) Imports
AvoidStarImport.allowClassImports = Whether to allow starred class imports like import <code>java.util.*;</code>. 
AvoidStarImport.allowStaticMemberImports = Whether to allow starred static member imports like <code>import static org.junit.Assert.*;</code>.

AvoidStaticImport.desc     = Checks that there are no static import statements.<br/>\r\nRationale: Importing static members can lead to naming conflicts between class' members. It may lead to poor code readability since it may no longer be clear what class a member resides in (without looking at the import statement).
AvoidStaticImport.excludes = Allows for certain classes via a star notation to be excluded such as <code>java.lang.Math.*</code> or specific static members to be excluded like <code>java.lang.System.out</code> for a variable or <code>java.lang.Math.random</code> for a method.<br/>\r\nIf you exclude a starred import on a class this automatically excludes each member individually.<br/>\r\nFor example: Excluding <code>java.lang.Math.*.</code> will allow the import of each static member in the Math class individually like <code>java.lang.Math.PI</code>.
AvoidStaticImport.name     = Avoid Static Imports

IllegalImport.desc        = Checks for imports from a set of illegal packages. By default, the check rejects all <code>sun.*</code> packages since programs that contain direct calls to the sun.* packages are <a href="http://java.sun.com/products/jdk/faq/faq-sun-packages.html" target="_blank">not 100% Pure Java</a>. To reject other packages, set property <code>illegalPkgs</code> to a list of the illegal packages.
IllegalImport.illegalPkgs = Comma (',') seperated list of illegal packages.
IllegalImport.name        = Illegal Imports

ImportControl.desc = Controls what can be imported in each package. Useful for ensuring that application layering rules are not violated, especially on large projects.<br/>\r\nThe DTD for a import control XML document is at http://www.puppycrawl.com/dtds/import_control_1_0.dtd. It contains documentation on each of the elements and attributes.<br/>\r\nThe check validates a XML document when it loads the document. To validate against the above DTD, include the following document type declaration in your XML document:\r\n<pre>\r\n<!DOCTYPE import-control PUBLIC\r\n    "-//Puppy Crawl//DTD Import Control 1.0//EN"\r\n    "http://www.puppycrawl.com/dtds/import_control_1_0.dtd">\r\n</pre>\r\n        
ImportControl.file = Name of the file containing the import control configuration.
ImportControl.name = Import Control
ImportControl.url  = url of the file containing the import control configuration.

ImportOrder.caseSensitive = whether strings comprision should be case sensitive or not
ImportOrder.desc          = Checks the ordering/grouping of imports. Ensures that groups of imports come in a specific order (e.g., java. comes first, javax. comes first, then everything else) and imports within each group are in lexicographic order. Static imports must be at the end of a group and in lexicographic order amongst themselves.
ImportOrder.groups        = list of imports groups (every group identified by string it's started)
ImportOrder.name          = Import Order Check
ImportOrder.option        = policy on the relative order between regular imports and static imports
ImportOrder.ordered       = whether imports within group should be sorted
ImportOrder.separated     = whether imports groups should be separated by, at least, one blank line

Imports.group = Imports

RedundantImport.desc = Checks for redundant import statements. An import statement is considered redundant if:\r\n<ul>\r\n<li>It is a duplicate of another import. This is, when a class is imported more than once.</li>\r\n<li>The class imported is from the java.lang package, e.g. importing java.lang.String.</li>\r\n<li>The class imported is from the same package.</li>\r\n</ul>
RedundantImport.name = Redundant Imports

UnusedImports.desc = Checks for unused import statements. Checkstyle uses a simple but very reliable algorithm to report on unused import statements. An import statement is considered unused if:\r\n<ul>\r\n<li>It is not referenced in the file. The algorithm does not support wild-card imports like <code>import java.io.*;</code>. Most IDE's provide very sophisticated checks for imports that handle wild-card imports.</li>\r\n<li>It is a duplicate of another import. This is when a class is imported more than once.</li>\r\n<li>The class imported is from the <code>java.lang</code> package. For example importing <code>java.lang.String</code>.</li>\r\n<li>The class imported is from the same package.</li>\r\n<li><b>Optionally:</b> it is referenced in Javadoc comments. This check is off by default, as it is considered bad practice to introduce a compile time dependency for documentation purposes only. As an example, the import java.util.Date would be considered referenced with the Javadoc comment {@link Date}. The alternative to avoid introducing a compile time dependency would be to write the Javadoc comment as {@link java.util.Date}.</li></ul>\r\n
UnusedImports.name = Unused Imports
UnusedImports.processJavadoc = Whether to process Javadoc
Javadoc.group                              = Javadoc Comments

JavadocMethod.allowMissingJavadoc          = Whether to ignore errors when a method javadoc is missed
JavadocMethod.allowMissingParamTags        = Whether to ignore errors when a method has parameters but does not have matching param tags in the javadoc.
JavadocMethod.allowMissingPropertyJavadoc  = Whether to allow missing Javadoc on accessor methods for properties (setters and getters).
JavadocMethod.allowMissingReturnTag        = Whether to ignore errors when a method returns non-void type does have a return tag in the javadoc.
JavadocMethod.allowMissingThrowsTags       = Whether to ignore errors when a method declares that it throws exceptions but does have matching throws tags in the javadoc.
JavadocMethod.allowThrowsTagsForSubclasses = Whether to allow documented exceptions that are subclass of one of declared exception.
JavadocMethod.allowUndeclaredRTE           = Whether to allow documented exceptions that are not declared if they are a subclass of java.lang.RuntimeException.
JavadocMethod.desc                         = Checks the Javadoc of a method or constructor. By default, does not check for unused throws. To allow documented java.lang.RuntimeExceptions that are not declared, set property allowUndeclaredRTE to true. The scope to verify is specified using the Scope class and defaults to Scope.PRIVATE. To verify another scope, set property scope to a different scope.<br/>\r\nError messages about parameters and type parameters for which no param tags are present can be suppressed by defining property <code>allowMissingParamTags</code>. Error messages about exceptions which are declared to be thrown, but for which no throws tag is present can be suppressed by defining property <code>allowMissingThrowsTags</code>. Error messages about methods which return non-void but for which no return tag is present can be suppressed by defining property <code>allowMissingReturnTag</code>.<br/>\r\n<br/>\r\nJavadoc is not required on a method that is tagged with the <code>@Override</code> annotation. However under Java 5 it is not possible to mark a method required for an interface (this was <em>corrected</em> under Java 6). Hence Checkstyle supports using the convention of using a single <code>{@inheritDoc}</code> tag instead of all the other tags. For example, if the following method is implementing a method required by an interface, then the Javadoc could be done as: \r\n<pre>\r\n/** {@inheritDoc} */\r\npublic int checkReturnTag(final int aTagIndex,\r\n                          JavadocTag[] aTags,\r\n                          int aLineNo)\r\n</pre> \r\n
JavadocMethod.excludeScope                 = visibility scope where Javadoc comments are not checked
JavadocMethod.logLoadErrors                = This check may need to load exception classes mentioned in the @throws tag to check whether they are RuntimeExceptions. If loading the class fails, this property allows to control checkstyle's error handling. If set to false (the default) a classpath configuration problem is assumed and the TreeWalker stops operating on the class completely. If set to true, checkstyle assumes a typo or refactoring problem in the javadoc and logs the problem in the normal checkstyle report (potentially masking a configuration error).
JavadocMethod.name                         = Method Javadoc
JavadocMethod.scope                        = Visibility scope where Javadoc comments are checked.
JavadocMethod.suppressLoadErrors           = Controls whether to show class loading errors in the checkstyle report.
JavadocMethod.tokens                       = Tokens to check.

JavadocPackage.allowLegacy = If set then allow the use of a package.html file.
JavadocPackage.desc        = Checks that each Java package has a Javadoc comment. By default it only allows a <code>package-info.java</code> file, but can be configured to allow a <code>package.html</code> file. \r\n<br/>\r\nAn error will be reported if both files exist as this is not allowed by the Javadoc tool. \r\n
JavadocPackage.name        = Package Javadoc

JavadocStyle.checkEmptyJavadoc  = Whether to check if the Javadoc is missing a describing text.
JavadocStyle.checkFirstSentence = Whether to check the first sentence for proper end of sentence.
JavadocStyle.endOfSentenceFormat= Format for matching the end of a sentence.
JavadocStyle.checkHtml          = Whether to check for incomplete html tags.
JavadocStyle.desc               = Validates Javadoc comments to help ensure they are well formed. The following checks are performed: 
JavadocStyle.excludeScope       = visibility scope where Javadoc comments are not checked.
JavadocStyle.name               = Style Javadoc
JavadocStyle.scope              = Visibility scope where Javadoc comments are checked.
JavadocStyle.tokens             = Tokens to check.

JavadocType.authorFormat  = Pattern for @author tag.
JavadocType.desc          = Checks Javadoc comments for class and interface definitions. By default, does not check for author or version tags. The scope to verify is specified using the Scope  class and defaults to Scope.PRIVATE. To verify another scope, set property scope to one of the Scope constants. To define the format for an author tag or a version tag, set property <cdoe>authorFormat</code> or <code>versionFormat</code> respectively to a  regular expression.<br/>\r\nError messages about type parameters for which no param tags are present can be suppressed by defining property <code>allowMissingParamTags</code>. 
JavadocType.excludeScope  = visibility scope where Javadoc comments are not checked
JavadocType.name          = Type Javadoc
JavadocType.scope         = Visibility scope where Javadoc comments are checked.
JavadocType.tokens        = Tokens to check.
JavadocType.versionFormat = Pattern for @version tag.
JavadocType.allowUnknownTags = Whether to ignore errors when a Javadoc tag is not recognised.

JavadocVariable.desc         = Checks that variables have Javadoc comments.
JavadocVariable.excludeScope = visibility scope where Javadoc comments are not checked
JavadocVariable.name         = Variable Javadoc
JavadocVariable.scope        = Visibility scope where Javadoc comments are checked.

WriteTag.desc        = Outputs a JavaDoc tag as information. Can be used e.g. with the stylesheets that sort the report by author name. To define the format for a tag, set property tagFormat to a regular expression. This check uses two different severity levels. The normal one is used for reporting when the tag is missing. The additional one (tagSeverity) is used for the level of reporting when the tag exists.
WriteTag.name        = Write Tag
WriteTag.tag         = Name of tag
WriteTag.tagFormat   = Format of tag
WriteTag.tagSeverity = Severity level when tag is found and printed
Metrics.group = Metrics

BooleanExpressionComplexity.desc   = Restrict the number of number of <code>&&, ||, &, |</code>  and <code>^</code> in an expression.<br/>\r\nRationale: Too many conditions leads to code that is difficult to read and hence debug and maintain.<br/>\r\nNote that the operators <code>&</code> and <code>|</code> are not only integer bitwise operators, they are also the non-shortcut versions of the boolean operators <code>&&</code> and <code>||</code>. 
BooleanExpressionComplexity.max    = the maximum allowed number of boolean operations in one experession.
BooleanExpressionComplexity.name   = Boolean Expression Complexity
BooleanExpressionComplexity.tokens = tokens to check

ClassDataAbstractionCoupling.desc = This metric measures the number of instantiations of other classes within the given class. This type of coupling is not caused by inheritance or the object oriented paradigm. Generally speaking, any abstract data type with other abstract data types as members has data abstraction coupling; therefore, if a class has a local variable that is an instantiation (object) of another class, there is data abstraction coupling. The higher the DAC, the more complex the data structure (classes) of the system.
ClassDataAbstractionCoupling.max  = the maximum threshold allowed
ClassDataAbstractionCoupling.name = Class Data Abstraction Coupling

ClassFanOutComplexity.desc = The number of other classes a given class relies on. Also the square of this has been shown to indicate the amount of maintenence required in functional programs (on a file basis) at least.
ClassFanOutComplexity.max  = the maximum threshold allowed
ClassFanOutComplexity.name = Class Fan Out Complexity

CyclomaticComplexity.desc = Checks cyclomatic complexity against a specified limit. The complexity is measured by the number of if, while, do, for, ?:, catch, switch, case  statements, and operators && and || (plus one) in the body of a constructor, method, static initializer, or instance initializer. It is a measure of the minimum number of possible paths through the source and therefore the number of required tests. Generally 1-4 is considered good, 5-7 ok, 8-10 consider re-factoring, and 11+ re-factor now!
CyclomaticComplexity.max  = the maximum threshold allowed
CyclomaticComplexity.name = Cyclomatic Complexity

JavaNCSS.classMaximum  = the maximum allowed number of non commenting lines in a class.
JavaNCSS.desc          = Determines complexity of methods, classes and files by counting the Non Commenting Source Statements (NCSS). This check adheres to the  specification for the JavaNCSS-Tool  written by Chr. Clemens Lee.<br/>\r\nRougly said the NCSS metric is calculated by counting the source lines which are not comments, (nearly) equivalent to counting the semicolons and opening curly braces.</br>\r\nThe NCSS for a class is summarized from the NCSS of all its methods, the NCSS of its nested classes and the number of member variable declarations.\r\nThe NCSS for a file is summarized from the ncss of all its top level classes, the number of imports and the package declaration.<br/>\r\nRationale: Too large methods and classes are hard to read and costly to maintain. A large NCSS number often means that a method or class has too many responsabilities and/or functionalities which should be decomposed into smaller units. 
JavaNCSS.fileMaximum   = the maximum allowed number of non commenting lines in a file.
JavaNCSS.methodMaximum = the maximum allowed number of non commenting lines in a method.
JavaNCSS.name          = Non Commenting Source Statements

NPathComplexity.desc = The NPATH metric computes the number of possible execution paths through a function. It takes into account the nesting of conditional statements and multi-part boolean expressions (e.g., A && B, C || D, etc.).<br/>\r\nRationale: Nejmeh says that his group had an informal NPATH limit of 200 on individual routines; functions that exceeded this value were candidates for further decomposition - or at least a closer look. 
NPathComplexity.max  = the maximum threshold allowed
NPathComplexity.name = NPath Complexity

ModifierOrder.desc = Checks that the order of modifiers conforms to the suggestions in the Java Language specification, sections 8.1.1, 8.3.1 and 8.4.3. The correct order is:\r\n<ol>\r\n<li>public</li>\r\n<li> protected</li>\r\n<li>private</li>\r\n<li>abstract</li>\r\n<li>static</li>\r\n<li>final</li>\r\n<li>transient</li>\r\n<li>volatile</li>\r\n<li>synchronized</li>\r\n<li>native</li>\r\n<li>strictfp</li>\r\n</ol>\r\n
ModifierOrder.name = Modifier Order

Modifiers.group = Modifiers

RedundantModifier.desc   = Checks for redundant modifiers in:\r\n<ol>\r\n<li>interface and annotation definitions,</li>\r\n<li>the final modifier on methods of final classes, and</li>\r\n<li>inner <code>interface</code> declarations that are declared as <code>static</code></li>\r\n</ol>\r\n<b>Rationale:</b> The Java Language Specification strongly discourages the usage of "public" and "abstract" for method declarations in interface definitions as a matter of style.<br/>\r\n<br/>\r\nVariables in interfaces and annotations are automatically public, static and final, so these modifiers are redundant as well.<br/>\r\n<br/>\r\nAs annotations are a form of interface, their fields are also automatically public, static and final just as their annotation fields are automatically public and abstract.<br/>\r\n<br/>\r\nFinal classes by definition can not be extended so the final modifier on the method of a final class is redundant.
RedundantModifier.name   = Redundant Modifier
RedundantModifier.tokens = Tokens to check.
Naming.group = Naming Conventions

AbstractClassName.desc   = Checks that abstract class names follow naming convention.
AbstractClassName.format = Regular expression defining required naming pattern.
AbstractClassName.name   = Abstract Class Name
AbstractClassName.ignoreModifier = Controls whether to ignore checking for the abstract modifier on classes that match the name.
AbstractClassName.ignoreName = Controls whether to ignore checking the name. Realistically only useful if using the check to identify that match name and do not have the abstract modifier. name.

ClassTypeParameterName.desc   = Checks that class type parameter names follow naming convention.
ClassTypeParameterName.format = Regular expression defining required naming pattern.
ClassTypeParameterName.name   = Class Type Parameter Name

ConstantName.applyToPackage   = Controls whether to apply the check to package-protected constant.
ConstantName.applyToPrivate   = Controls whether to apply the check to private constant.
ConstantName.applyToProtected = Controls whether to apply the check to protected constant.
ConstantName.applyToPublic    = Controls whether to apply the check to public constant.
ConstantName.desc   = Checks that constants (static final fields) variables follow naming convention.
ConstantName.format = Regular expression defining required naming pattern.
ConstantName.name   = Constant Names

LocalFinalVariableName.desc   = Checks that local final variables follow naming convention.
LocalFinalVariableName.format = Regular expression defining required naming pattern.
LocalFinalVariableName.name   = Local Final Variable Names

LocalVariableName.desc   = Checks that local variables follow naming convention.
LocalVariableName.format = Regular expression defining required naming pattern.
LocalVariableName.name   = Local Variable Names
LocalVariableName.tokens = Tokens to check.

MemberName.applyToPackage   = Controls whether to apply the check to package-protected member.
MemberName.applyToPrivate   = Controls whether to apply the check to private member.
MemberName.applyToProtected = Controls whether to apply the check to protected member.
MemberName.applyToPublic    = Controls whether to apply the check to public member.
MemberName.desc             = Checks that member variables (non-static fields) follow naming convention.
MemberName.format           = Regular expression defining required naming pattern.
MemberName.name             = Member Names

MethodName.desc   = Checks that method names follow naming convention.
MethodName.format = Regular expression defining required naming pattern.
MethodName.name   = Method Names

MethodTypeParameterName.desc   = Checks that method type parameter names follow naming convention.
MethodTypeParameterName.format = Regular expression defining required naming pattern.
MethodTypeParameterName.name   = Method Type Parameter Name

PackageName.desc   = Checks that package names follow naming convention.
PackageName.format = Regular expression defining required naming pattern.
PackageName.name   = Package Names

ParameterName.desc   = Checks that parameter names follow naming convention.
ParameterName.format = Regular expression defining required naming pattern.
ParameterName.name   = Parameter Names

StaticVariableName.applyToPackage   = Controls whether to apply the check to package-protected static variable.
StaticVariableName.applyToPrivate   = Controls whether to apply the check to private static variable.
StaticVariableName.applyToProtected = Controls whether to apply the check to protected static variable.
StaticVariableName.applyToPublic    = Controls whether to apply the check to public static variable.
StaticVariableName.desc   = Checks that static variables (static, non-final fields) follow naming convention.
StaticVariableName.format = Regular expression defining required naming pattern.
StaticVariableName.name   = Static Variable Names

TypeName.applyToPackage   = Controls whether to apply the check to package-protected type.
TypeName.applyToPrivate   = Controls whether to apply the check to private type.
TypeName.applyToProtected = Controls whether to apply the check to protected type.
TypeName.applyToPublic    = Controls whether to apply the check to public type.
TypeName.desc   = Checks that class names follow naming convention.
TypeName.format = Regular expression defining required naming pattern.
TypeName.name   = Type Names
TypeName.tokens = Tokens to check.

Regexp.group                        = Regexp

RegexpMultiline.desc       = A check for detecting multiple lines that match a supplied regular expression. Works with any file type.\r\n<br/><br/>\r\nRationale: This check can be used to prototype checks and to find common bad practice such as calling ex.printStacktrace(), System.out.println(), System.exit(), etc. 
RegexpMultiline.format     = illegal pattern 
RegexpMultiline.ignoreCase = Controls whether to ignore case when searching. 
RegexpMultiline.maximum    = The maximum number of matches required in each file. 
RegexpMultiline.message    = message which is used to notify about violations, if empty then default(hard-coded) message is used.  \u0009 
RegexpMultiline.minimum    = The minimum number of matches required in each file.
RegexpMultiline.name       = RegexpMultiline

RegexpSingleline.desc               = A check for detecting single lines that match a supplied regular expression. Works with any file type.\r\n<br/><br/>\r\nRationale: This check can be used to prototype checks and to find common bad practice such as calling ex.printStacktrace(), System.out.println(), System.exit(), etc. 
RegexpSingleline.format             = illegal pattern 
RegexpSingleline.ignoreCase         = Controls whether to ignore case when searching. 
RegexpSingleline.maximum            = The maximum number of matches required in each file. 
RegexpSingleline.message            = message which is used to notify about violations, if empty then default(hard-coded) message is used.  \u0009 
RegexpSingleline.minimum            = The minimum number of matches required in each file.
RegexpSingleline.name               = RegexpSingleline

RegexpSinglelineJava.desc           = This class is variation on <code>RegexpSingleline</code> for detecting single lines that match a supplied regular expression in Java files. It supports suppressing matches in Java comments. 
RegexpSinglelineJava.format         = illegal pattern 
RegexpSinglelineJava.ignoreCase     = Controls whether to ignore case when searching. 
RegexpSinglelineJava.ignoreComments = Controls whether to ignore text in comments when searching. 
RegexpSinglelineJava.maximum        = The maximum number of matches required in each file. 
RegexpSinglelineJava.message        = message which is used to notify about violations, if empty then default(hard-coded) message is used.  \u0009 
RegexpSinglelineJava.minimum        = The minimum number of matches required in each file.
RegexpSinglelineJava.name           = RegexpSingleLineJava

AnonInnerLength.desc = Checks for long anonymous inner classes.<br/>\r\nRationale: If an anonymous inner class becomes very long it is hard to understand and to see the flow of the method where the class is defined. Therefore long anonymous inner classes should usually be refactored into a named inner class. See also Bloch, Effective Java, p. 93. 
AnonInnerLength.max  = maximum allowable number of lines.
AnonInnerLength.name = Anonymous inner classes lengths

ExecutableStatementCount.desc   = Restricts the number of executable statements to a specified limit
ExecutableStatementCount.max    = Maximum allowed parameters.
ExecutableStatementCount.name   = Executable Statement Size
ExecutableStatementCount.tokens = Tokens to check.

FileLength.desc = Checks for long source files.<br/>\r\nRationale: If a source file becomes very long it is hard to understand. Therefore long classes should usually be refactored into several individual classes that focus on a specific task. 
FileLength.max  = Maximum number of lines allowed.
FileLength.name = Maximum File Length

LineLength.desc          = Checks for long lines.<br/>\r\nRationale: Long lines are hard to read in printouts or if developers have limited screen space for the source code, e.g. if the IDE displays additional information like project tree, class hierarchy, etc. 
LineLength.ignorePattern = Pattern for lines to ignore.
LineLength.max           = Maximum allowed line length.
LineLength.name          = Maximum Line Length
LineLength.tabWidth      = Number of characters to count for each tab character.

MethodLength.countEmpty = whether to count empty lines and single line comments of the form //
MethodLength.desc       = Checks for long methods and constructors.<br/>\r\nRationale: If a method becomes very long it is hard to understand. Therefore long methods should usually be refactored into several individual methods that focus on a specific task. 
MethodLength.max        = Maximum number of lines allowed.
MethodLength.name       = Maximum Method Length
MethodLength.tokens     = Tokens to check.

OuterTypeNumber.desc = Checks for the number of types declared at the outer (or root) level in a file.<br/>\r\n<br/>\r\nRationale: It is considered good practice to only define one outer type per file. 
OuterTypeNumber.max  = maximum allowable number of outer types
OuterTypeNumber.name = Outer Type Number

ParameterNumber.desc   = Checks the number of parameters of a method or constructor.
ParameterNumber.max    = Maximum allowed parameters.
ParameterNumber.name   = Maximum Parameters
ParameterNumber.tokens = Tokens to check.

Sizes.group = Size Violations

MethodCount.name         = Method Count 
MethodCount.desc         = Checks the number of methods declared in each type.<br/>This includes the number of each scope (private, package, protected and public) as well as an overall total. 
MethodCount.maxTotal     = maximum allowable number of methods at all scope levels
MethodCount.maxPrivate   = maximum allowable number of private methods
MethodCount.maxPackage   = maximum allowable number of package methods
MethodCount.maxProtected = maximum allowable number of protected methods
MethodCount.maxPublic    = maximum allowable number of public methods

EmptyForInitializerPad.desc   = Checks the padding of an empty for initializer; that is whether white space is required at an empty for initializer, or such white space is forbidden. No check occurs if there is a line wrap at the initializer, as in\r\n<pre>\r\nfor (\r\n      ; i < j; i++, j--)\r\n</pre>\r\n\u0009
EmptyForInitializerPad.name   = Empty For Initializer Pad
EmptyForInitializerPad.option = Policy on how to pad an empty for iterator.

EmptyForIteratorPad.desc   = Checks the padding of an empty for iterator; that is whether white space is required at an empty for iterator, or such white space is forbidden. No check occurs if there is a line wrap at the iterator, as in\r\n<pre>\r\nfor (Iterator foo = very.long.line.iterator();\r\n      foo.hasNext();\r\n     )\r\n</pre>\r\n\u0009\r\n\u0009\u0009
EmptyForIteratorPad.name   = Empty For Iterator Pad
EmptyForIteratorPad.option = Policy on how to pad an empty for iterator.

FileTabCharacter.desc     = Checks that there are no tab characters ('\\t') in the source code.<br/>\r\n<br/>\r\nRationale:<br/>\r\n<ul>\r\n<li>Developers should not need to configure the tab width of their text editors in order to be able to read source code.</li>\r\n<li>From the Apache jakarta coding standards: In a distributed development environment, when the commit messages get sent to a mailing list, they are almost impossible to read if you use tabs.</li>\r\n</ul>\r\n
FileTabCharacter.eachLine = whether to report on each line containing a tab, or just the first instance
FileTabCharacter.name     = File Tab Character

GenericWhitespace.desc = Checks that the whitespace around the Generic tokens < and > is correct to the <em>typical</em> convention. The convention is not configurable. \r\n<br/><br/>\r\nFor example the following is legal: \r\n<pre>\r\nList<Integer> x = new ArrayList<Integer>();\r\nList<List<Integer>> y = new ArrayList<List<Integer>>();\r\n</pre>\r\nBut the following example is not:\r\n<pre>\r\nList < Integer > x = new ArrayList < Integer > ();\r\nList < List < Integer > > y = new ArrayList < List < Integer > > ();\r\n</pre>\r\n   \r\n
GenericWhitespace.name = Generic Whitespace

MethodParamPad.allowLineBreaks = whether a line break between the identifier and left parenthesis is allowed
MethodParamPad.desc            = Checks the padding between the identifier of a method definition, constructor definition, method call, or constructor invocation; and the left parenthesis of the parameter list. That is, if the identifier and left parenthesis are on the same line, checks whether a space is required immediately after the identifier or such a space is forbidden. If they are not on the same line, reports an error, unless configured to allow line breaks. To allow linebreaks after the identifier, set property <code>allowLineBreaks</code> to <code>true</code>.
MethodParamPad.name            = Method Parameter Pad
MethodParamPad.option          = policy on how to pad method parameter
MethodParamPad.tokens          = Tokens to check.

NoWhitespaceAfter.allowLineBreaks = Whether whitespace is allowed if the token is at a linebreak.
NoWhitespaceAfter.desc            = Checks that there is no whitespace after a token. More specifically, it checks that it is not followed by whitespace, or (if linebreaks are allowed) all characters on the line after are whitespace. To forbid linebreaks after a token, set property <code>allowLineBreaks</code> to <code>false</code>.
NoWhitespaceAfter.name            = No Whitespace After
NoWhitespaceAfter.tokens          = Tokens to check.

NoWhitespaceBefore.allowLineBreaks = Whether whitespace is allowed if the token is at a linebreak.
NoWhitespaceBefore.desc            = Checks that there is no whitespace before a token. More specifically, it checks that it is not preceded with whitespace, or (if linebreaks are allowed) all characters on the line before are whitespace. To allow linebreaks before a token, set property <code>allowLineBreaks</code> to <code>true</code>.
NoWhitespaceBefore.name            = No Whitespace Before
NoWhitespaceBefore.tokens          = Tokens to check.

OperatorWrap.desc   = Checks the policy on how to wrap lines on operators.
OperatorWrap.name   = Operator Wrap
OperatorWrap.option = Policy on how to wrap lines. nl = operator must be on a new line, eol = operator must be at the end of the line.
OperatorWrap.tokens = Tokens to check.

ParenPad.desc   = Checks the policy on the padding of parentheses; i.e. whether a space is required after a left parenthesis and before a right parenthesis, or such spaces are forbidden.
ParenPad.name   = Paren Pad
ParenPad.option = Policy on how to pad parentheses. nospace = do not pad (e.g. method(a, b)).  space = ensure padding (e.g. method( a, b )).
ParenPad.tokens = Tokens to check.

TabCharacter.desc = Checks that there are no tab characters ('\\\\t') in the source code.<br/>\r\nRationale:\r\n<ul>\r\n<li>Developers should not need to configure the tab width of their text editors in order to be able to read source code.</li>\r\n<li>From the Apache jakarta coding standards: In a distributed development environment, when the cvs commit messages get sent to a mailing list, they are almost impossible to read if you use tabs.</li>\r\n</ul>\r\n
TabCharacter.name = Tab Character

TypecastParenPad.desc   = Checks the policy on the padding of parentheses for typecasts. That is, whether a space is required after a left parenthesis and before a right parenthesis, or such spaces are forbidden. 
TypecastParenPad.name   = Typecast Paren Pad
TypecastParenPad.option = Policy on how to pad parentheses. nospace = do not pad (e.g. method(a, b)).  space = ensure padding (e.g. method( a, b )).
TypecastParenPad.tokens = Tokens to check.

Whitespace.group                        = Whitespace

WhitespaceAfter.desc   = Checks that a token is followed by whitespace.
WhitespaceAfter.name   = Whitespace After
WhitespaceAfter.tokens = Tokens to check.

WhitespaceAround.allowEmptyConstructors = allow empty constructor bodies
WhitespaceAround.allowEmptyMethods      = allow empty method bodies
WhitespaceAround.desc                   = Checks that a token is surrounded by whitespace. Empty constructor and method bodies (blocks) of the form\r\n<pre>\r\npublic MyClass() {}      // empty constructor\r\npublic void func() {}    // empty method\r\n</pre>\r\nmay optionally be exempted from the policy using the <code>allowEmptyMethods</code> and <code>allowEmptyConstructors</code> properties. 
WhitespaceAround.name                   = Whitespace Around
WhitespaceAround.tokens                 = Tokens to check.
WhitespaceAround.ignoreEnhancedForColon = Whether or not to ignore a colon in an enhanced for loop
Filters.group = Filters

SeverityMatchFilter.acceptOnMatch = If acceptOnMatch is true, then the filter accepts an audit event if and only if there is a match between the event's severity level and property severity. If acceptOnMatch is false, then the filter accepts an audit event if and only if there is not a match between the event's severity level and property severity.
SeverityMatchFilter.desc          = Filter SeverityMatchFilter decides audit events according to the severity level of the event.
SeverityMatchFilter.name          = Severity Match Filter
SeverityMatchFilter.severity      = the severity level of this filter.

SuppressWithNearbyCommentFilter.checkC          = whether to check C style comments (/* ... */)
SuppressWithNearbyCommentFilter.checkCPP        = whether to check C++ style comments (//)
SuppressWithNearbyCommentFilter.checkFormat     = check pattern to suppress.
SuppressWithNearbyCommentFilter.commentFormat   = comment pattern to trigger filter to begin suppression.
SuppressWithNearbyCommentFilter.desc            = Filter <code>SuppressWithNearbyCommentFilter</code> uses individual comments to suppress audit events.<br/>\r\n<br/><br/>\r\nRationale: Same as SuppressionCommentFilter. Whereas the SuppressionCommentFilter uses matched pairs of filters to turn on/off comment matching, SuppressWithNearbyCommentFilter uses single comments. This requires fewer lines to mark a region, and may be aesthetically preferable in some contexts.\r\n<br/><br/>\r\nUsage: This filter only works in conjunction with a FileContentsHolder, since that check makes the suppression comments in the .java files available sub rosa. A configuration that includes this filter must configure FileContentsHolder as a child module of TreeWalker. 
SuppressWithNearbyCommentFilter.influenceFormat = a negative/zero/positive value that defines the number of lines preceding/at/following the suppression comment 
SuppressWithNearbyCommentFilter.messageFormat   = message pattern to suppress.
SuppressWithNearbyCommentFilter.name            = Suppress With Nearby Comment Filter

SuppressionCommentFilter.checkC           = whether to check C style comments (/* ... */)
SuppressionCommentFilter.checkCPP         = whether to check C++ style comments (//)
SuppressionCommentFilter.checkFormat      = check pattern to suppress.
SuppressionCommentFilter.desc             = Filter <code>SuppressionCommentFilter</code> uses pairs of comments to suppress audit events.<br/>\r\nRationale: Sometimes there are legitimate reasons for violating a check. When this is a matter of the code in question and not personal preference, the best place to override the policy is in the code itself. Semi-structured comments can be associated with the check. This is sometimes superior to a separate suppressions file, which must be kept up-to-date as the source file is edited.
SuppressionCommentFilter.messageFormat    = message pattern to suppress.
SuppressionCommentFilter.name             = Suppression Comment Filter
SuppressionCommentFilter.offCommentFormat = comment pattern to trigger filter to begin suppression.
SuppressionCommentFilter.onCommentFormat  = comment pattern to trigger filter to end suppression.

SuppressionFilter.desc = Filter <code>SuppressionFilter</code> rejects audit events for Check errors according to a <a href="http://checkstyle.sourceforge.net/config.html#XML%20Details" target="_blank">suppressions XML document</a> in a file. If there is no configured suppressions file, the Filter accepts all audit events.
SuppressionFilter.file = the location of the suppressions XML document file. The location can either be a filesystem location, or a name passed to the ClassLoader.getResource() method.
SuppressionFilter.name = Suppression Filter
